\subsection{Points-to Analyse}
\label{subsec:pointsto}

Die Points-To Analysis (dt. Pointer-Analyse) ist eine Technik zur Berechnung der Menge von Objekten bzw. dessen Speicherbereichen, auf die eine Programm Variable zur Laufzeit zeigen kann\cite{Hind2001, Smaragdakis2015}. Da das zu analysierende Programm bzw. dessen kompletter Quellcode vorliegen muss, ist die Pointer-Analyse eine statische Analysetechnik.

Die Pointer Analyse startet mit allen Eingangspunkten, beispielsweise der main()-Methode. Dann werden iterativ alle erreichbaren Methoden verarbeitet, bis ein Fixpunkt erreicht ist. Der Java-Bytecode wird durch das Frontend des Compilers\footnote{das Frontend ist eine von 3 Stufen des Kompilierungsvorganges (Frontend, Middleend, Backend), auch Analysephase genannt.} in eine Zwischenform überführt (engl. intermediate representation = IR), die das Programm repräsentiert und weitere Optimierungen und Transformationen ermöglicht\cite{Simon2015}. 
Diese Zwischenform wird als nächstes in einen sog. \textit{type-flow graph} konvertiert. Jeder Knoten stellt eine Operation auf einem Objekttypen dar. Die gerichteten Kanten verlaufen von der Definition des Objektes bis zur tatsächlichen Verwendung. Jeder Knoten verwaltet eine Liste mit Typen (engl. \textit{type state}), die diesen Knoten erreichen können (siehe Abbildung~\ref{fig:typeflowgraph}). 
Die Listen werden durch die Kanten des Graphen propagiert, sobald einer Liste Typen hinzugefügt werden, wird die Änderung an alle weiteren Verwendungen (Kindelemente eines Knotens) propagiert. Typlisten dürfen nur Elemente hinzugefügt werden, nicht aber Elemente entfernt aus ihnen werden, damit sichergestellt ist das die Analyse den Fixpunkt erreicht und terminiert. Für jeden Typ, schaut die Pointer Analyse ob der dieser instanziiert ist, falls dem so ist wird er durch Bytecodes markiert. Für jedes Feld, wird separat ermittelt ob die Felder nur gelesen oder auch geschrieben werden. Dadurch können Felder gefunden werden die nur gelesen aber, während der Laufzeit, nicht geschrieben werden. Die Werte solcher Felder werden dann bereits während der Ahead-of-time Kompilierung berechnet, statt erst zur Laufzeit (sog. \textit{constant-folding}, \cite[Kapitel 4.2]{Grumberg2014}).

\begin{figure}[!ht]
%figure full paperwidth and trim the left and right empty space from it
   \makebox[\textwidth]{
     \includegraphics[trim = 8mm 0mm 16mm 0mm,width=1.1\paperwidth]{resources/graal-tutorial-at-cgo-2015.jpg}
   }
\caption{Type-flow Graph, \cite[Folie 71 \& 72]{Wimmer2015}}
	\label{fig:typeflowgraph}
\end{figure}
